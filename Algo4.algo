//Read Size Array
FUNCTION read-size() : INTEGER
VAR
    var n :INTEGER;
BEGIN
   REPEAT
       write ("put the size of the array");
       read (n);
   UNTIL n>1
   return (n);
END

//Read Elements
PROCEDURE read-ele(n:integer, var t: ARRAY_OF INTEGER)
VAR
    i:integer;
BEGIN
    FOR i from 0 to n-1 DO
    read(t[i]);
    END_FOR
END

//Quick Sorting the Array
PROCEDURE sort( arr : ARRAY_OF INTEGER)
VAR
  // Create an auxiliary stack
  stack : STACK;
  p : INTEGER;
BEGIN
   // pushing initial values of l and h to stack
   stack.push(l);
   stack.push(h);
   // keep popping from the stack while is not empty
   WHILE (NOT stack.isEmpty()) DO
       // pop h and l
       h := stack.pop();
       l := stack.pop();
       // set pivot element at its correct position
       // in a sorted array
       p := partition(arr,l,h);
       // if there are elements on the right side of the pivot,
       // then push right side to stack
       IF (p+1 < h) THEN
           stack.push(p+1);
           stack.push(h);
       END_IF
   END_WHILE

END

FUNCTION inser(arr : ARRAY_OF INTEGER, low, high : INTEGER) : INTEGER 
VAR
   b,i,pivot : INTEGER;
BEGIN
  pivot := arr[high]; //pivot
  i := low-1; // index of smaller element
  FOR i FROM low TO high-1 DO
       // if the current element is smaller than the pivot
       IF (arr[i] < pivot) THEN
           i := i+1;
           swap(arr[i],arr[i])
       END_IF
  END_FOR
   swap(arr[b+1],arr[i])

   RETURN b+1 ;
END



ALGORITHM algo 4
VAR
    arr: ARRAY_OF INTEGER;
    s,n : integer;
BEGIN
    n:= read-size(); //Read the size of the array
    read-ele(n,arr); //Read the elements of the array
    sort(arr); //Sorting the array
    arr:= inser(s,arr); //Inserting element in sorted array
    
END